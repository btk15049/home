# Codeforces Round ECR41 (div2 only)
## A
hi

## B
hi

## C
うに2つが思いつけば一瞬

## D
なんか１頂点固定して偏角ソートして傾きごとにmapに突っ込んで頑張った．  
二つ傾きもってきて，どちらも頂点０と繋いじゃダメな点であるならその二点を結ぶしかないみたいなことをやりました．  
乱択解は頭が良すぎるため．

## E
(i,hoge),(hoge,i)となる条件について考えると，`hoge<a[i],i<a[hoge]`である必要があるため，
i < a[hoge]を満たすhogeについて，s[hoge]=1, そうでない場合はs[hoge]=0としてやると，sum(s[0],...,s[hoge-1])が答えになる．
よって上からaddしながらBIT芸をすればよい．

## F
候補となる文字列対は必ず中心が(i,N-i)みたいな感じになり，中心をi,半径をdとする文字列をs[i,d]と表すと，s[i,d]==s[N-1,d]が成り立つときs[i,d-1]==d[N-i,d-1]も成り立つみたいな単調性が現れる．よって，中心を決めると半径をどこまで伸ばせるかみたいなのは二分探索で求めることができる．このとき，文字列の一致判定をO(1)またはO(log)でやる必要があるので，ローリングハッシュを使う．とハッシュキラーに殺される．writer許さない．えでゅふぉでハッシュキラー入れる意味なくない？SA-IS＋RMQ書くと通る．

## G
解説を読みました．  
s(n,k):=サイズnの順列を区別しないk個の空でない集合に分割する組み合わせとする．（例えば{1,2,3,4}->{{1,2}{3}{4}})  
これは包除原理を使うとO(k)で求められ，`s(n,k)=sum((-1)^i kC(k-i) (k-i)^n)/k!`みたいに求められる．  
ある分割Rのある集合Sのある要素iについて，a[i]が関係するコストは`|S|a[i]`である．これについて，以下のように式変形する．  
`|S|a[i]=sum_{j in S}(a[i])=a[i](sum_{j in S}(1))=a[i](sum_{j in S,i=j}(1)+sum_{j in S,i!=j}(1))`  
これについて，前半分の総和は明らかに`sum(a[i])s(n,k)`である．後ろ半分については，自分以外の個数に依存するため，同じグループに自身以外の要素がいる必要がある．これは，サイズn-1,集合数kの分割を持ってきて，そこに要素を足すと考えればよく，1つの分割への足し方のコストの総和はn-1である．  
よって，`sum(a[i])s(n,k)+(n-1)s(n-1,k)`が答え．


### 新しく学んだこと
* こどふぉのwriterの人間性を信用してはいけない．

