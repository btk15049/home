# みんなのプロコン2018 本戦 
writer: camypaper
## A
とても苦手なタイプ．
## B
3べき思いついてから時間がかかりすぎです．
## C
見た瞬間重心分解なのにできないのは明らかに経験値不足．
## D
初めてみるタイプ．  
解法は2種類ぐらいあって，Z algorithmを知っていればそれを応用して復元するほうが楽だと思う．  
そうでない解法は[CSAのこれ](https://csacademy.com/contest/archive/task/substring-restrictions)を使う．日本語の文章があまりなさそうなので，解法をここに書いておく（まだ公式解説がない）  
R(a,b,len):= S[a:a+len]とS[b:b+len]が等しい
と略記する．
問題を少し読みかえると，「R(a,b,l)という制約がN個あり，それを全て満たす文字列は存在するか？」という問題になる．  
R(a,b,l)について，R(a,b,k)とR(a+l-k,b+l-k,k)の二つの制約に分離してしまっても問題がないことに着目する(但し，2*k>=l)
．sparse tableと同じノリになると，kを2べきの長さにできることがわかる．よって，この問題は「R(a,b,2^p)という2N個の制約を全て満たすような文字列が存在は存在するか？」という問題になった．  
ここで，UFをlogN個用意しておく（唐突）．  
R(a,b,2^p)という制約があったとき，p番目のUFでunite(a,b)をする．これは長さ2^pの部分文字列について，どこと等しいかみたいな情報をUFで管理しておくことができる．この情報をO(N)個のUFの辺情報で管理できることが重要なポイント．  
また，R(a,b,2^p)という制約はR(a,b,2^(p-1))とR(a+2^(p-1),b+2^(p-1),2^(p-1))の二つの制約に分解できる．上記のO(N)個の制約を2N個の制約に分解して，p-1番目のUFに追加する．これをlogN,...,0と上から伝播させることで，どことどこの文字が一緒か，みたいなUFで構成できる．あとはUFの情報から文字列を復元し，Z algorithmかなんかで元の数列と一致するかどうか適当にやると全体NlogNでできる．

## E
読んでいません

### 新しく学んだこと
* 互いに素なものを数え上げるときは素因数を考えて包除原理で重複を取り除くのが定石
* Z algorithmを新たに習得．復元も似たような処理で可能．
* 重心分解をすると，任意のパスはただ一つのパスを通るような列挙の仕方が可能
