#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

#ifdef BTK
#define DEBUG if(1)
#else
#define DEBUG if(0)
#endif

#define ALL(v) (v).begin(),(v).end()
#define REC(ret, ...) std::function<ret (__VA_ARGS__)>
template <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}
template <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}
template <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}

class range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};


namespace pre {
	double p[60][60];
	double sum[60];
	constexpr int NG = 59;
	struct latte {
		latte() {
			p[1][0] = 1.0;
			p[1][NG] = 0.0;
			sum[1] = 1.0;
			for (int i : range(2,55)) {
				for (int j : range(i)) {
					p[i][j] = p[i - 1][NG] / i;
				}
				for (int j : range(i - 1)) {
					for (int k : range(j + 1)) {
						p[i][k] += p[i - 1][j] / i;
					}
					for (int k : range(j + 1, i)) {
						p[i][NG] += p[i - 1][j] / i;
					}
				}
				sum[i] = 0;
				for (int j : range(i))sum[i] += p[i][j];
			}
		}
	}malta;
}

//The number of outdegree of vertex in graph "in" is 1
constexpr int USED = -2;
constexpr int BRANCH = -1;
constexpr int UNCYCLE = 11234567;
struct sunny_graph {
	using V = vector<int>;
	using Graph = vector<V>;
	int size;
	Graph g; // g[i]    : vertexes of i th component's loop
	Graph in;// in[v]   : reverse edges(not in loop) toward v 
	V K;     // K[v]    : id of connected component contains v
	V root;  // root[v] : root vertex of v (same connected components)
	int dfs1(int v, V& out, int id, V &loop) {
		auto &sign = K;
		sign[v] = -2;
		int u = out[v];
		if (sign[u] >= 0) {
			sign[v] = UNCYCLE;
			return BRANCH;
		}
		if (sign[u] == USED || (u = dfs1(u, out, id, loop)) >= 0) {
			sign[v] = id;
			root[v] = v;
			loop.push_back(v);
			if (v == u)return BRANCH;
			else return u;
		}
		K[v] = UNCYCLE;
		return BRANCH;
	}
	void dfs2(int v) {
		for (auto &u : in[v]) {
			K[u] = K[v];
			root[u] = root[v];
			dfs2(u);
		}
	}
	sunny_graph(V out) {
		size = out.size();
		in.resize(size);
		K.resize(size, -1);
		root.resize(size);
		int id = 0;
		for (int v = 0; v < size; v++){
			V L;
			if (K[v] == -1)dfs1(v, out, id, L);
			if (L.size()) {
				g.push_back(L);
				id++;
			}
		}
		for (int v = 0; v < size; v++)
			if (K[v] == UNCYCLE)in[out[v]].push_back(v);
		for (auto &s : g)for (auto &v : s)dfs2(v);
	}
};

class Privateparty {
public:
	double getexp(vector <int>);
};

double Privateparty::getexp(vector <int> a) {
	int n = a.size();
	sunny_graph sg(a);
	vector<int> depth(n);
	stack<int> s;
	for (auto &loop : sg.g) {
		for (int v : loop) {
			s.push(v);
			depth[v] = loop.size();
		}
	}
	while (s.empty() == false) {
		int v = s.top(); s.pop();
		for (int u : sg.in[v]) {
			depth[u] = depth[v] + 1;
			s.push(u);
		}
	}
	double ret = 0;
	for (int i : range(n)) {
		ret += pre::sum[depth[i]];
	}
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, double p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	Privateparty *obj;
	double answer;
	obj = new Privateparty();
	clock_t startTime = clock();
	answer = obj->getexp(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p1 - answer) <= 1e-9 * max(1.0, fabs(p1));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	double p1;
	
	{
	// ----- test 0 -----
	int t0[] = {0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2.0;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1.5;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2.5;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {0,1,1,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3.166666666666667;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {3,2,1,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2.0;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by [KawigiEdit] 2.0!


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
