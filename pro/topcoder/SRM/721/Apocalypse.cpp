#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)
#define REP(i,n) FOR(i,0,n)
#define ALL(v) (v).begin(),(v).end()
#define fi first
#define se second
#define pb push_back
#define DEBUG if(0)
#define REC(ret, ...) std::function<ret (__VA_ARGS__)>
template <typename T>inline void chmin(T &l,T r){l=min(l,r);}
template <typename T>inline void chmax(T &l,T r){l=max(l,r);}


struct edge{
    int flow,to,rev;
};
typedef vector<edge> E;
typedef vector<E> Graph;
#define pb push_back
void addedge(Graph&g,int from,int to,int f,int rf=0){
    int x=g[from].size();
    int y=g[to].size();
    g[from].pb(edge{f,to,y});
    g[to].pb(edge{rf,from,x});
}

vector<int> bfs(Graph& G,int s){
    int N = G.size();
    queue<int> que;
    vector<int> dist(N,-1);
    dist[s] = 0;
    que.push(s);
    for(;!que.empty();que.pop()){
        auto v=que.front();
        for(auto& e : G[v])
            if(e.flow>0&&dist[e.to]==-1){
                dist[e.to] = dist[v] + 1;
                que.push(e.to);
        }
    }
    return dist;
}

int maxflow(Graph& G,int s,int t){
    int res=0;
    int N = G.size();
    while(true){
        auto dist = bfs(G,s);
        if(dist[t] < 0)break;
        vector<unsigned> iter(N,0);
        std::function<int(int,int)> dfs=[&](int v,int f){
            if(v==s)return f;
            for(auto &i = iter[v]; i < G[v].size(); i++){
                edge &e = G[v][i];
                edge &re = G[e.to][e.rev];
                if(re.flow>0 && dist[v] >dist[e.to]){
                    int d=dfs(e.to,min(f,re.flow));
                    if(d>0){e.flow+=d;re.flow-=d;return d;}
                }
            }
            return 0;
        };
        int f;
        while((f=dfs(t,114514))> 0)res+=f;
    }
    return res;
}


typedef vector<int> V;
typedef vector<V> VV;
class Apocalypse {
public:
    int maximalSurvival(vector <int> p, vector <int> pos, int t) {
        int N=p.size()+1;
        V src(N,0);
        for(auto &it:pos)src[it]=1;
        vector<VV> l(N,VV(t+1,V(2)));
        int M=0;
        int S=M++;
        int T=M++;
        for(auto &a:l)for(auto &b:a)for(auto &c:b)c=M++;
        
        Graph g(M);
        REP(i,N){
            if(src[i]){
                addedge(g,S,l[i][0][1],1);
            }
            else{
                addedge(g,l[i].back()[0],T,1);
            }
        }
        REP(i,N)REP(j,t+1)addedge(g,l[i][j][0],l[i][j][1],1);
        REP(i,N)REP(j,t)addedge(g,l[i][j][1],l[i][j+1][0],1);
        REP(i,N-1){
            int x=i+1;
            int y=p[i];
            REP(j,t){
                addedge(g,l[x][j][1],l[y][j+1][0],1);
                addedge(g,l[y][j][1],l[x][j+1][0],1);
            }
        }
        return maxflow(g,S,T);
    }
};















// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	Apocalypse *obj;
	int answer;
	obj = new Apocalypse();
	clock_t startTime = clock();
	answer = obj->maximalSurvival(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << p3 << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << answer << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	int p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = {0,1,2};
	p1 = {2,3};
	p2 = 1;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = {0,1,2};
	p1 = {2,3};
	p2 = 2;
	p3 = 2;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = {0,0,0,1,2,3};
	p1 = {1,2,3};
	p2 = 1;
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = {0,1,2,3,4,5,6,7,8,9};
	p1 = {0,1,2,3,4,5,6};
	p2 = 50;
	p3 = 4;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = {0};
	p1 = {0,1};
	p2 = 1;
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = {0,0,0};
	p1 = {1,2};
	p2 = 1;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// We have an undirected tree with n nodes, numbered 0 through n-1.
// You are given its description: a vector <int> p with n-1 elements.
// For each valid i, there is an edge between nodes p[i] and (i+1).
// 
// 
// There are k tokens on the tree, each in a different node.
// You are given a vector <int> position.
// The elements of position are the numbers of the nodes that contain the tokens.
// 
// 
// A demon has placed k bombs onto the tree: one bomb into each node that currently contains a token.
// The bombs will all explode after t turns.
// If there is a token in a node with a bomb when the bomb explodes, the token is destroyed.
// Your task is to save as many tokens as possible.
// 
// 
// In each turn you can move each token at most once: from its current node to any adjacent node.
// Whenever you move a token, the destination node must be empty.
// In other words, each node must always contain at most one token.
// You get to choose the order in which to move the tokens, and the order may be different in different turns.
// 
// 
// Compute and return the maximal number of tokens saved from the explosions.
// 
// DEFINITION
// Class:Apocalypse
// Method:maximalSurvival
// Parameters:vector <int>, vector <int>, int
// Returns:int
// Method signature:int maximalSurvival(vector <int> p, vector <int> position, int t)
// 
// 
// CONSTRAINTS
// -n will be between 2 and 50, inclusive.
// -p will contain exactly n-1 elements.
// -For each i, 0 <= p[i] <= i.
// -position will contain between 1 and n elements, inclusive.
// -Each element in position will be between 0 and n-1, inclusive.
// -Elements in position will be distinct.
// -t will be between 1 and 50, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {0,1,2}
// {2,3}
// 1
// 
// Returns: 1
// 
// 
// The tree is a line: 0 - 1 - 2 - 3.
// Initially, the tokens and the bombs are in the nodes 2 and 3.
// We have only one turn.
// Whatever we do, the token that starts on node 3 will be destroyed.
// We can save the other token by moving it from node 2 to node 1.
// 
// 
// 1)
// {0,1,2}
// {2,3}
// 2
// 
// Returns: 2
// 
// 
// This is the same setting as in Example 0, but now we have two turns.
// Now we can save both tokens.
// In the first turn we first move the token from node 2 to node 1 and only then we move the token from node 3 to node 2 (which is now empty).
// In the second turn we move both tokens again: from 1 to 0 and then from 2 to 1.
// 
// 
// 2)
// {0,0,0,1,2,3}
// {1,2,3}
// 1
// 
// Returns: 3
// 
// 
// 
// 3)
// {0,1,2,3,4,5,6,7,8,9}
// {0,1,2,3,4,5,6}
// 50
// 
// Returns: 4
// 
// 
// 
// 4)
// {0}
// {0,1}
// 1
// 
// Returns: 0
// 
// 
// 
// 5)
// {0,0,0}
// {1,2}
// 1
// 
// Returns: 1
// 
// We can only save one of the two tokens, because we only have a single turn and we cannot push both of them into the same node.
// 
// END KAWIGIEDIT TESTING
