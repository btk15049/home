#ifndef _WIN32
#include<bits/stdc++.h>
#else
#define _CRT_SECURE_NO_WARNINGS
#include"../../../vs.hpp"
#endif


using namespace std;
typedef long long LL;
#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)
#define REP(i,n) FOR(i,0,n)
#define ALL(v) (v).begin(),(v).end()
#define fi first
#define se second
#define pb push_back
#define DEBUG if(0)
#define REC(ret, ...) std::function<ret (__VA_ARGS__)>
template <typename T>inline void chmin(T &l,T r){l=min(l,r);}
template <typename T>inline void chmax(T &l,T r){l=max(l,r);}

typedef vector<int> V;
class GraphAndPairs {
public:
    int dist;
    V ret;
    int id;
    pair<int,int> getpath(){
        int bg=id;
        int ed=id;
        REP(i,dist-2){
            ret.pb(ed);
            ed++;
            ret.pb(ed);
        }
        id=ed+1;
        return {bg,ed};
    }
    void f(int a,int num){
        REP(i,num){
            ret.pb(a);
            ret.pb(id++);
        }
    }

    int solve(int rest){
        if(dist==2){
            int v=1;
            while(v*(v+1)/2<=rest)v++;
            auto p=getpath();
            f(p.fi,v);
            return rest-v*(v-1)/2;
        }
        if(rest<=50){
            auto p=getpath();
            f(p.fi,1);
            f(p.se,rest);
            return 0;
        }

        else{
            int v=1;
            while((v+1)*(v+1)<=rest){
                v++;
            }
            auto p=getpath();
            f(p.fi,v);
            f(p.se,v);
            return rest-v*v;
        }
    }
    vector <int> construct(int d, int k) {
        id=0;
        ret=V();
        dist=d;
        while(1){
            if(k==0)break;
            k=solve(k);
        }
        ret.pb(id);
        reverse(ALL(ret));
        return ret;

    }
};















// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, vector <int> p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	GraphAndPairs *obj;
	vector <int> answer;
	obj = new GraphAndPairs();
	clock_t startTime = clock();
	answer = obj->construct(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		if (answer.size() != p2.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p2[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
		if (hasAnswer) {
			cout << "Desired answer:" << endl;
			cout << "\t" << "{";
			for (int i = 0; int(p2.size()) > i; ++i) {
				if (i > 0) {
					cout << ",";
				}
				cout << p2[i];
			}
			cout << "}" << endl;
		}
		cout << "Your answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(answer.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << answer[i];
		}
		cout << "}" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	vector <int> p2;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 2;
	p1 = 1;
	p2 = {4,0,1,1,3,3,2,2,0,1,2};
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 2;
	p1 = 2;
	p2 = {8,0,1,1,3,3,2,2,0,1,2,4,5,5,7,7,6,6,4,5,6};
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 4;
	p1 = 4;
	p2 = {8,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,0};
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 5;
	p1 = 2;
	p2 = {10,0,1,1,2,2,3,3,4,5,6,6,7,7,8,8,9,0,5,1,6,2,7,3,8,4,9};
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Let G be a simple undirected graph.
// An unordered pair {a, b} of nodes in G is called a good pair if a and b are in the same connected component of G and the distance between a and b is exactly d.
// (The distance between two nodes is the smallest number of edges on a path from one node to the other.)
// 
// 
// You are given the int d and an int k.
// Construct an undirected graph G with the following properties:
// 
// The graph must be simple (i.e., no self-loops and no multiple edges).
// The number of nodes n must be between 3 and 1,000, inclusive.
// The nodes must be numbered 0 through n-1.
// The number of edges m must be between 2 and 1,000, inclusive.
// The graph must contain exactly k good pairs of nodes.
// 
// 
// Return a vector <int> with a description of the graph G you constructed: its number of vertices followed by a list of its edges.
// More precisely, the description should have the form {n, a[0], b[0], a[1], b[1], ..., a[m-1], b[m-1]}, 
// where n is the number of nodes, and for each i the graph contains an edge between a[i] and b[i].
// 
// 
// You may assume that each valid test case has a solution.
// If there are multiple solutions, you may return any of them.
// 
// DEFINITION
// Class:GraphAndPairs
// Method:construct
// Parameters:int, int
// Returns:vector <int>
// Method signature:vector <int> construct(int d, int k)
// 
// 
// CONSTRAINTS
// -d will be between 2 and 50, inclusive.
// -k will be between 1 and 50,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 1
// 
// Returns: {4, 0, 1, 1, 3, 3, 2, 2, 0, 1, 2 }
// 
// The graph looks as follows:
// 
// ????
// 0 - 1
// | / |
// 2 - 3
// 
// 
// The only good pair of vertices is {0, 3}.
// 
// 1)
// 2
// 2
// 
// Returns: {8, 0, 1, 1, 3, 3, 2, 2, 0, 1, 2, 4, 5, 5, 7, 7, 6, 6, 4, 5, 6 }
// 
// This time the graph looks as follows:
// ????
// 
// 0 - 1  4 - 5
// | / |  | / |
// 2 - 3  6 - 7
// 
// 
// The good pairs are {0, 3} and {4, 7}.
// 
// 2)
// 4
// 4
// 
// Returns: {8, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 0 }
// 
// 
// 
// 3)
// 5
// 2
// 
// Returns: {10, 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 0, 5, 1, 6, 2, 7, 3, 8, 4, 9 }
// 
// 
// 
// END KAWIGIEDIT TESTING
